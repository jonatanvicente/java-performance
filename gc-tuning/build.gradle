plugins {
    id 'java'
    id 'application'
}

group = 'org.example'
version = 'unspecified'


application {
    mainClass = 'tuning.GCBehaviorTest'
}

/*
        Profile 1:
        Baja latencia (GC menor frecuente, pausas cortas)
            Reducir al máximo las pausas, promoviendo lentamente, y con un Young Gen relativamente grande para evitar GCs mayores.
 */
tasks.named('run') {
    jvmArgs = [
            '-XX:+UseG1GC',
            '-XX:MaxTenuringThreshold=15',
            '-XX:SurvivorRatio=6',
            '-XX:G1HeapRegionSize=1m',
            '-XX:InitiatingHeapOccupancyPercent=45',
            '-Xms128m',
            '-Xmx128m'
    ]
}

/*
    Profile 2: Alto throughput (velocidad total, sin importar pausas largas)
        Maximizar el rendimiento general, asumiendo pausas de GC mayores. Se promueve rápidamente y se limpia rápido.
*/

/*tasks.named('run') {
    jvmArgs = [
            '-XX:+UseParallelGC',
            '-XX:MaxTenuringThreshold=1',
            '-XX:SurvivorRatio=8',
            '-XX:+UseTLAB',
            '-Xms128m',
            '-Xmx128m'
    ]
}*/


/*
    Profile 3: Memoria limitada (heap pequeña y control de promociones
    Usar eficientemente una heap pequeña. Se evita promoción innecesaria y se cuida el espacio en Survivor.
 */

/*tasks.named('run') {
    jvmArgs = [
            '-XX:+UseSerialGC',
            '-XX:MaxTenuringThreshold=5',
            '-XX:SurvivorRatio=4',
            '-XX:NewRatio=2',
            '-Xms64m',
            '-Xmx64m'
    ]
}*/

/*

  Profile 4: Aplicación reactiva (microservicios con respuesta rápida)
  GC adaptado a microservicios REST donde las pausas deben ser mínimas. Uso de G1GC moderno y heap pequeña con tuning.

 */
/*tasks.named('run') {
    jvmArgs = [
            '-XX:+UseG1GC',
            '-XX:MaxTenuringThreshold=8',
            '-XX:SurvivorRatio=6',
            '-XX:G1ReservePercent=20',
            '-XX:InitiatingHeapOccupancyPercent=30',
            '-Xms128m',
            '-Xmx128m'
    ]
}*/


/*
     A revisar (visualvm / jmc):
        - Uso de Eden: Cuánto tiempo tarda en llenarse.
        - Survivor: Si los objetos viven varios GCs o no.
        - Old Gen: Cuánto tarda en llenarse. ¿Hay promociones agresivas?
        - GC Events: Duración de las pausas, frecuencia, tipo (Minor, Major, Mixed).
 */


repositories {
    mavenCentral()
}

dependencies {
    testImplementation platform('org.junit:junit-bom:5.10.0')
    testImplementation 'org.junit.jupiter:junit-jupiter'
}

test {
    useJUnitPlatform()
}